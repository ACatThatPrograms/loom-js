import { EvmContract } from './evm-contract'
import { Transaction } from './proto/loom_pb'

/**
 * The provider manages the web3 calls to a endpoint, however the LoomProvider
 * wraps the web3 call which intent to be sent to an Ethereum node and turn it
 * into a Loom call for a Loom Contract
 */
export class LoomProvider {
  /**
   * @param contract: The contract which wraps an ethereum EVM
   */
  constructor(protected contract: EvmContract) {}

  _callAsync(data: string): Promise<any> {
    return this.contract.callAsync<void>(data)
  }

  _callStaticAsync(data: string): Promise<any> {
    return this.contract.callAsync<Transaction>(data, new Transaction())
  }

  // Basic response to web3js
  _okResponse(result: any = 0): any {
    return { id: 0, jsonrpc: '2.0', result: [result] }
  }

  /**
   * Should be used to make async request
   * This method is used internally by web3, so we adapt it to be used with loom contract
   * when we are wrapping the evm on a DAppChain
   * @param payload JSON payload generated by web3 which will be translated to loom transaction/call
   * @param callback Triggered on end with (err, result)
   */
  send(payload: any, callback: Function) {
    // Methods frequently called by web3js added just to follow the web3 requirements
    const okMethods = ['eth_estimateGas', 'eth_gasPrice']

    /**
     * NOTE: _okResponse and okMethods array are mocks, only to allow web3js think that is talking
     * to an Ethereum Node
     */

    let ret = null

    // Ok just avoids web3js issues
    if (okMethods.indexOf(payload.method) !== -1) {
      ret = this._okResponse()
    }

    // Sending transaction to Loom DAppChain
    else if (payload.method === 'eth_sendTransaction') {
      this._callAsync(payload.params[0].data)
        .then((result: any) => callback(null, this._okResponse()))
        .catch((err: Error) => callback(err, null))
    }

    // Sending a static call to Loom DAppChain
    else if (payload.method === 'eth_call') {
      this._callStaticAsync(payload.params[0].data)
        .then((result: Transaction) => callback(null, this._okResponse(result.getData())))
        .catch((err: Error) => callback(err, null))
    }

    // Required to avoid web3js error, because web3js always want to know about a transaction
    else if (payload.method === 'eth_getTransactionReceipt') {
      // TODO: Wrap this correctly to return real status of transaction
      ret = {
        id: 0,
        jsonrpc: '2.0',
        result: {
          transactionHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
          transactionIndex: '0x00',
          blockHash: '0x0000000000000000000000000000000000000000000000000000000000000000',
          blockNumber: '0x00',
          gasUsed: '0x0',
          cumulativeGasUsed: '0x0',
          contractAddress: null,
          logs: [],
          status: '0x01'
        }
      }
    }

    // Warn the user about we don't support other methods
    else {
      return callback(Error(`Method "${payload.method}" not supported on this provider`), null)
    }

    if (ret) callback(null, ret)
  }
}
